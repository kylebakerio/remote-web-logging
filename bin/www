#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('log-share:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
console.log("on port", port)
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);


// adding socket.io stuff
const io = require('socket.io')(server, {
  cors: {
    origin: true, //"https://example.com",
    path: '/',
    serveClient: false,
    methods: ["GET", "POST"],
    // allowedHeaders: ["my-custom-header"],
    credentials: true
  }
});

const serverStart = new Date();

const userAuthenticated = {
  // dynamically populated
};

const sessions = []

const sessionUserMap = {
  // id : index
}

const sessionDateMap = {
  // date: index
}

const watchLiveMap = {
  // id: bool
}

const getActiveUserCount = () => {
  let count = 0;
  for (let [id, socket] of io.of("/").sockets) {
    count++
  }
  return count
}

io.on('connection', (socket) => {
  socket.emit('chat message', "> connected to server, server up since " + serverStart) // make private message to this user
  io.emit('chat message', 'new client connected')

  socket.on('console', (msg) => {
    // share with authenticated connected users:
    for (let [id, socket] of io.of("/").sockets) {
      console.log("check auth of",id)
      if (userAuthenticated[id]) {
        console.log(id, 'is authorized')
        // io.emit('sharedConsole', msg) // make private message to this user
        if (watchLiveMap[id]) socket.emit('sharedConsole', msg) // maybe this does it?
      } else {
        console.log(id, 'is not authorized')
      }
    }
    //

    // store in sessions:
    if (!sessionUserMap.hasOwnProperty(socket.id)) {
      const userSessionDate = new Date()
      sessionUserMap[socket.id] = sessions.length;
      sessionDateMap[(userSessionDate)] = sessions.length;
      sessions.push([]);
      io.emit('chat message', 'new session broadcast started: ' + userSessionDate)
    }
    const sessionIndex = sessionUserMap[socket.id];
    sessions[sessionIndex].push(msg);
    //

    // log into the server
    try {
      msg = JSON.parse(msg)

      console.group(msg.method, msg.args[0])
      console[msg.method](...(msg.args))
      console.log(msg.trace)
      console.groupEnd()
    } catch (e) {
      console.error("!!!!likely error with client message",e,msg)
    }
    //
  });

  socket.on("chat message", (msg) => {
    // pretend we're just a nice friendly chat app, but allow privacy guarantee with "//" in any chat
    let alreadyEcho = false;
    const echoBack = () => {
      if (alreadyEcho) return
      socket.emit('chat message', "- " + msg);
      alreadyEcho=true
    }; // used if we don't hit the last block
    const shareDateMenu = () => socket.emit('chat message', ["> sessions available for replay:"].concat(Object.keys(sessionDateMap).concat('> copy/paste a date to replay that log session')).join('\n'))
    let wasCommand = false;
    
    let lowercasedMessage = msg.toLowerCase()
    if (lowercasedMessage.includes("ireallyamsuchahugefanofpuppies")) {
      echoBack()
      console.log("authenticated user",socket.id)
      userAuthenticated[socket.id] = true;
      watchLiveMap[socket.id] = true;
      socket.emit('chat message','> welcome watcher')
      shareDateMenu()
      // send message that user authenticated
    }

    if (checkAuth(socket)) {
      
      if (lowercasedMessage.includes('usercount')) {
        echoBack()
        const userCount = getActiveUserCount();
        socket.emit('chat message', "> " + userCount)  
      }
      if (lowercasedMessage.includes('serverstart')) {
        echoBack()
        socket.emit('chat message', "> " + serverStart)  
      }
      if (lowercasedMessage.includes("howtowatch")) {
        echoBack()
        socket.emit('chat message', '> url.com?shareLogs=true&sessionMessage=any-helpful-description')      
      }
      if (lowercasedMessage.includes('dates')) {
        echoBack()
        shareDateMenu()
      }
      if (lowercasedMessage.includes('commands')) {
        echoBack()
        socket.emit('chat message', '> dates, liveon, liveoff, [timestamp], mobilemodeon, mobilemodeoff, howtowatch, serverstart, usercount')
      }
      if (lowercasedMessage.includes('liveoff')) {
        echoBack()
        watchLiveMap[socket.id] = false;
        socket.emit('chat message', '> live off')
      }
      if (lowercasedMessage.includes('liveon')) {
        echoBack()
        watchLiveMap[socket.id] = true;
        socket.emit('chat message', '> live on')
      }
      if (lowercasedMessage.includes('GMT')) {
        echoBack()
        const sessionIndex = sessionDateMap[msg];
        console.log(msg, "index is", sessionIndex)
        if (sessionIndex > -1) {
          // socket.emit('sharedConsole', JSON.stringify({method:"groupCollapsed", args:["begin replay of: " + msg]}))
          sessions[sessionIndex].forEach(aLog => {
            socket.emit('sharedConsole', aLog)
          })
          // socket.emit('sharedConsole', JSON.stringify({method:"groupEnd", args:["end replay of: " + msg]}))
          socket.emit('chat message', '> replay end')
        } else {
          socket.emit('chat message', '> failed - must be perfect copy/paste of whole timestamp')
        }
      }
    } 
    if (!alreadyEcho) {
      if (msg.includes('//')) {
        // guaranteed privacy, prevents leaked typos
        echoBack();
      } else {
        io.emit('chat message','+ '+msg)
      }
      // socket.broadcast.emit('chat message',"+"+msg)
    }

  })
});

function checkAuth(socket) {
  return userAuthenticated[socket.id];
}
//


/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
