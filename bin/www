#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('log-share:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
console.log("on port", port)
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);


// adding socket.io stuff
const io = require('socket.io')(server, {
  cors: {
    origin: true, //"https://example.com",
    path: '/',
    serveClient: false,
    methods: ["GET", "POST"],
    // allowedHeaders: ["my-custom-header"],
    credentials: true
  }
});

const userAuthenticated = {
  // dynamically populated
};

const sessions = []

const sessionUserMap = {
  // id : index
}

const sessionDateMap = {
  // date: index
}

const watchLiveMap = {
  // id: bool
}

io.on('connection', (socket) => {


  socket.on('console', (msg) => {
    // share with authenticated connected users:
    for (let [id, socket] of io.of("/").sockets) {
      console.log("check auth of",id)
      if (userAuthenticated[id]) {
        console.log(id, 'is authorized')
        // io.emit('sharedConsole', msg) // make private message to this user
        if (watchLiveMap[id]) socket.emit('sharedConsole', msg) // maybe this does it?

      } else {
        console.log(id, 'is not authorized')
      }
    }
    //

    // store in sessions:
    if (!sessionUserMap.hasOwnProperty(socket.id)) {
      sessionUserMap[socket.id] = sessions.length;
      sessionDateMap[(new Date())] = sessions.length;
      sessions.push([]);
    }
    const sessionIndex = sessionUserMap[socket.id];
    sessions[sessionIndex].push(msg);
    //

    // log into the server
    try {
      msg = JSON.parse(msg)

      console.group(msg.method, msg.args[0])
      console[msg.method](...(msg.args))
      console.log(msg.trace)
      console.groupEnd()
    } catch (e) {
      console.error("!!!!likely error with client message",e,msg)
    }
    //
  });

  socket.on("chat message", (msg) => {
    // pretend we're just a nice friendly chat app, but allow privacy guarantee with "//" in any chat
    
    const echoBack = () => socket.emit('chat message', "- " + msg); // used if we don't hit the last block
    const shareDateMenu = () => socket.emit('chat message', ["> sessions available for replay:"].concat(Object.keys(sessionDateMap).concat('> copy/paste a date to replay that log session')).join('\n'))
    
    if (msg.includes("ireallyamsuchahugefanofpuppies")) {
      echoBack()
      console.log("authenticated user",socket.id)
      userAuthenticated[socket.id] = true;
      watchLiveMap[socket.id] = true;
      socket.emit('chat message','> welcome')
      shareDateMenu()
      // send message that user authenticated
    }
    else if (checkAuth(socket) && msg.includes('dates')) {
      echoBack()
      shareDateMenu()
    }
    else if (checkAuth(socket) && msg.includes('commands')) {
      echoBack()
      socket.emit('chat message', '> dates, live on, live off, [timestamp]')
    }
    else if (msg.includes('> live off')) {
      echoBack()
      watchLiveMap[socket.id] = false;
      socket.emit('chat message', 'done')
    }
    else if (msg.includes('> live on')) {
      echoBack()
      watchLiveMap[socket.id] = true;
      socket.emit('chat message', '> done')
    }
    else if (checkAuth(socket) && msg.includes('GMT')) {
      echoBack()
      const sessionIndex = sessionDateMap[msg];
      console.log(msg, "index is", sessionIndex)
      if (sessionIndex > -1) {
        // socket.emit('sharedConsole', JSON.stringify({method:"groupCollapsed", args:["begin replay of: " + msg]}))
        sessions[sessionIndex].forEach(aLog => {
          socket.emit('sharedConsole', aLog)
        })
        // socket.emit('sharedConsole', JSON.stringify({method:"groupEnd", args:["end replay of: " + msg]}))
        socket.emit('chat message', '> done')
      } else {
        socket.emit('chat message', '> failed - must be perfect copy/paste of whole timestamp')
      }
    }
    else {
      if (msg.includes('//')) {
        // guaranteed privacy, prevents leaked typos
        echoBack();
      } else {
        io.emit('chat message','+ '+msg)
      }
      // socket.broadcast.emit('chat message',"+"+msg)
    }

  })
});

function checkAuth(socket) {
  return userAuthenticated[socket.id];
}
//


/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
